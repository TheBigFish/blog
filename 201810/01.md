# tornado-异步上下文管理（StackContext）

## 初步使用
```python
# -*- coding: utf-8 -*-
import tornado.ioloop
import tornado.stack_context

ioloop = tornado.ioloop.IOLoop.instance()

times = 0

def callback():
    print 'run callback'
    raise ValueError('except in callback')


def async_task():
    global times
    times += 1
    print 'run async task {}'.format(times)
    ioloop.add_callback(callback=callback)


def main():
    try:
        async_task()
    except Exception as e:
        print 'main exception {}'.format(e)
    print 'end'

main()
ioloop.start()
```
异常没有在 main中捕获：
```
run async task 1
end
run callback
ERROR:root:Exception in callback <function null_wrapper at 0x7f23ec300488>
Traceback (most recent call last):
  File "/home/turtlebot/learn/tornado/tornado1/ioloop.py", line 370, in _run_callback
```

## 包裹上下文
使用partial 生成新的函数,最终调用的函数为 wrapper(callback)，在 wrapper 中捕获异常
```python
# -*- coding: utf-8 -*-
import tornado.ioloop
import tornado.stack_context
import functools

ioloop = tornado.ioloop.IOLoop.instance()

times = 0

def callback():
    print 'run callback'
    raise ValueError('except in callback')

def wrapper(func):
    try:
        func()
    except Exception as e:
        print 'main exception {}'.format(e)

def async_task():
    global times
    times += 1
    print 'run async task {}'.format(times)
    # 使用 partial 生成新的函数
    # 最终 ioloop 调用的函数为 wrapper(callback)
    ioloop.add_callback(callback=functools.partial(wrapper, callback))

def main():
    try:
        async_task()
    except Exception as e:
        print 'main exception {}'.format(e)
    print 'end'

main()
ioloop.start()
```
异常被正确捕获：
```
run async task 1
end
run callback
main exception except in callback
```
## 使用tornado stack_context例子
```python
# -*- coding: utf-8 -*-
import tornado.ioloop
import tornado.stack_context
import contextlib

ioloop = tornado.ioloop.IOLoop.instance()

times = 0

def callback():
    print 'Run callback'
    raise ValueError('except in callback')

def async_task():
    global times
    times += 1
    print 'run async task {}'.format(times)
    ioloop.add_callback(callback=callback)

@contextlib.contextmanager
def contextor():
    print 'Enter contextor'
    try:
        yield
    except Exception as e:
        print 'Handler except'
        print 'exception {}'.format(e)
    finally:
        print 'Release'

def main():
    stack_context = tornado.stack_context.StackContext(contextor)
    with stack_context:
        async_task()
    print 'End'


main()
ioloop.start()
```

### tornado.stack_context.StackContext
tornado.stack_context 相当于一个上下文包裹器，它接收一个 context_factory 作为参数并保存  
context_factory 是一个上下文类，拥有 `__enter__` `__exit__`方法

使用 with stack_context 时候，执行自己的 `__enter__`  
`__enter__` 函数根据保存的 context_factory 创建一个 context 对象，并执行对象的 `__enter__`方法  
StackContext 将(StackContext, context_factory)保存，将来执行回调的时候再创建一个 StackContext(context_factory) 来执行 call_back

```python

class StackContext(object):
    def __init__(self, context_factory):
        self.context_factory = context_factory

    def __enter__(self):
        self.old_contexts = _state.contexts
        # _state.contexts is a tuple of (class, arg) pairs
        _state.contexts = (self.old_contexts + 
                           ((StackContext, self.context_factory),))
        try:
            self.context = self.context_factory()
            self.context.__enter__()
        except Exception:
            _state.contexts = self.old_contexts
            raise

    def __exit__(self, type, value, traceback):
        try:
            return self.context.__exit__(type, value, traceback)
        finally:
            _state.contexts = self.old_contexts
```